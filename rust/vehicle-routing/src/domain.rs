//! Domain model for Vehicle Routing Problem.
//!
//! Pure annotations - all shadow variable updates generated by macros.

use serde::{Deserialize, Serialize};
use solverforge::prelude::*;

/// Average driving speed in km/h for travel time estimation.
pub const AVERAGE_SPEED_KMPH: f64 = 50.0;

/// Earth radius in meters for haversine calculation.
const EARTH_RADIUS_M: f64 = 6_371_000.0;

/// A geographic location with latitude and longitude.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Location {
    pub index: usize,
    pub latitude: f64,
    pub longitude: f64,
}

impl PartialEq for Location {
    fn eq(&self, other: &Self) -> bool {
        self.index == other.index
    }
}

impl Eq for Location {}

impl std::hash::Hash for Location {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.index.hash(state);
    }
}

impl Location {
    pub fn new(index: usize, latitude: f64, longitude: f64) -> Self {
        Self { index, latitude, longitude }
    }

    pub fn distance_meters(&self, other: &Location) -> f64 {
        if self.latitude == other.latitude && self.longitude == other.longitude {
            return 0.0;
        }
        let lat1 = self.latitude.to_radians();
        let lat2 = other.latitude.to_radians();
        let dlat = lat2 - lat1;
        let dlon = (other.longitude - self.longitude).to_radians();
        let a = (dlat / 2.0).sin().powi(2) + lat1.cos() * lat2.cos() * (dlon / 2.0).sin().powi(2);
        EARTH_RADIUS_M * 2.0 * a.sqrt().asin()
    }

    pub fn travel_time_seconds(&self, other: &Location) -> i64 {
        (self.distance_meters(other) * 3.6 / AVERAGE_SPEED_KMPH).round() as i64
    }
}

/// A customer visit with time window and demand constraints.
#[planning_entity]
#[derive(Serialize, Deserialize)]
pub struct Visit {
    #[planning_id]
    pub index: usize,
    pub name: String,
    pub location: Location,
    pub demand: i32,
    #[serde(rename = "minStartTime")]
    pub min_start_time: i64,
    #[serde(rename = "maxEndTime")]
    pub max_end_time: i64,
    #[serde(rename = "serviceDuration")]
    pub service_duration: i64,

    /// Shadow: which vehicle this visit is assigned to.
    #[inverse_relation_shadow_variable(source_variable_name = "visits")]
    #[serde(skip)]
    pub vehicle_idx: Option<usize>,

    /// Shadow: previous visit in route.
    #[previous_element_shadow_variable(source_variable_name = "visits")]
    #[serde(skip)]
    pub previous_visit_idx: Option<usize>,

    /// Shadow: arrival time (cascading from previous).
    #[serde(skip)]
    pub arrival_time: Option<i64>,
}

impl Visit {
    pub fn new(index: usize, name: impl Into<String>, location: Location) -> Self {
        Self {
            index,
            name: name.into(),
            location,
            demand: 1,
            min_start_time: 0,
            max_end_time: 24 * 3600,
            service_duration: 0,
            vehicle_idx: None,
            previous_visit_idx: None,
            arrival_time: None,
        }
    }

    pub fn with_demand(mut self, demand: i32) -> Self {
        self.demand = demand;
        self
    }

    pub fn with_time_window(mut self, min_start: i64, max_end: i64) -> Self {
        self.min_start_time = min_start;
        self.max_end_time = max_end;
        self
    }

    pub fn with_service_duration(mut self, duration: i64) -> Self {
        self.service_duration = duration;
        self
    }

    #[inline]
    pub fn late_minutes(&self) -> i64 {
        self.arrival_time.map_or(0, |arrival| {
            let service_start = arrival.max(self.min_start_time);
            let service_end = service_start + self.service_duration;
            ((service_end - self.max_end_time).max(0) + 59) / 60
        })
    }
}

/// A delivery vehicle with capacity and assigned route.
#[planning_entity]
#[derive(Serialize, Deserialize)]
pub struct Vehicle {
    #[planning_id]
    pub id: usize,
    pub name: String,
    pub capacity: i32,
    #[serde(rename = "homeLocation")]
    pub home_location: Location,
    #[serde(rename = "departureTime")]
    pub departure_time: i64,
    #[planning_list_variable]
    #[serde(default)]
    pub visits: Vec<usize>,

    /// Cached: total demand (updated by macro).
    #[serde(skip)]
    pub cached_total_demand: i32,
    /// Cached: driving time in seconds (updated by macro).
    #[serde(skip)]
    pub cached_driving_time: i64,
    /// Cached: late minutes (updated by macro).
    #[serde(skip)]
    pub cached_late_minutes: i64,
}

impl Vehicle {
    pub fn new(id: usize, name: impl Into<String>, capacity: i32, home_location: Location) -> Self {
        Self {
            id,
            name: name.into(),
            capacity,
            home_location,
            departure_time: 8 * 3600,
            visits: Vec::new(),
            cached_total_demand: 0,
            cached_driving_time: 0,
            cached_late_minutes: 0,
        }
    }

    pub fn with_departure_time(mut self, time: i64) -> Self {
        self.departure_time = time;
        self
    }

    #[inline]
    pub fn excess_demand(&self) -> i32 {
        (self.cached_total_demand - self.capacity).max(0)
    }

    #[inline]
    pub fn driving_time_minutes(&self) -> i64 {
        self.cached_driving_time / 60
    }

    #[inline]
    pub fn late_minutes(&self) -> i64 {
        self.cached_late_minutes
    }
}

/// The complete vehicle routing solution.
#[planning_solution(constraints = "crate::constraints::define_constraints")]
#[shadow_variable_updates(
    list_owner = "vehicles",
    list_field = "visits",
    element_collection = "visits",
    element_type = "usize",
    inverse_field = "vehicle_idx",
    previous_field = "previous_visit_idx",
    cascading_listener = "compute_arrival_time",
    post_update_listener = "compute_vehicle_caches"
)]
#[derive(Serialize, Deserialize)]
pub struct VehicleRoutePlan {
    pub name: String,
    #[serde(rename = "southWestCorner")]
    pub south_west_corner: [f64; 2],
    #[serde(rename = "northEastCorner")]
    pub north_east_corner: [f64; 2],
    #[problem_fact_collection]
    pub locations: Vec<Location>,
    #[planning_entity_collection]
    pub visits: Vec<Visit>,
    #[planning_entity_collection]
    pub vehicles: Vec<Vehicle>,
    #[planning_score]
    pub score: Option<HardSoftScore>,
    #[serde(rename = "solverStatus", skip_serializing_if = "Option::is_none")]
    pub solver_status: Option<String>,
    #[serde(skip)]
    pub travel_time_matrix: Vec<Vec<i64>>,
}

impl VehicleRoutePlan {
    pub fn new(
        name: impl Into<String>,
        locations: Vec<Location>,
        visits: Vec<Visit>,
        vehicles: Vec<Vehicle>,
    ) -> Self {
        let (sw, ne) = Self::compute_bounds(&locations);
        Self {
            name: name.into(),
            south_west_corner: sw,
            north_east_corner: ne,
            locations,
            visits,
            vehicles,
            score: None,
            solver_status: None,
            travel_time_matrix: Vec::new(),
        }
    }

    fn compute_bounds(locations: &[Location]) -> ([f64; 2], [f64; 2]) {
        if locations.is_empty() {
            return ([0.0, 0.0], [0.0, 0.0]);
        }
        let (mut min_lat, mut max_lat) = (f64::MAX, f64::MIN);
        let (mut min_lon, mut max_lon) = (f64::MAX, f64::MIN);
        for loc in locations {
            min_lat = min_lat.min(loc.latitude);
            max_lat = max_lat.max(loc.latitude);
            min_lon = min_lon.min(loc.longitude);
            max_lon = max_lon.max(loc.longitude);
        }
        ([min_lat, min_lon], [max_lat, max_lon])
    }

    pub fn finalize(&mut self) {
        let n = self.locations.len();
        self.travel_time_matrix = vec![vec![0; n]; n];
        for i in 0..n {
            for j in 0..n {
                if i != j {
                    self.travel_time_matrix[i][j] =
                        self.locations[i].travel_time_seconds(&self.locations[j]);
                }
            }
        }
    }

    #[inline]
    pub fn travel_time(&self, from_idx: usize, to_idx: usize) -> i64 {
        self.travel_time_matrix
            .get(from_idx)
            .and_then(|row| row.get(to_idx))
            .copied()
            .unwrap_or(0)
    }

    /// Cascading shadow: compute arrival_time for a visit.
    fn compute_arrival_time(&mut self, visit_idx: usize) {
        let vehicle_idx = match self.visits[visit_idx].vehicle_idx {
            Some(idx) => idx,
            None => return,
        };
        let (prev_loc, prev_time) = match self.visits[visit_idx].previous_visit_idx {
            Some(prev_idx) => {
                let prev = &self.visits[prev_idx];
                let arr = prev.arrival_time.unwrap_or(0);
                let start = arr.max(prev.min_start_time);
                (prev.location.index, start + prev.service_duration)
            }
            None => {
                let v = &self.vehicles[vehicle_idx];
                (v.home_location.index, v.departure_time)
            }
        };
        let travel = self.travel_time(prev_loc, self.visits[visit_idx].location.index);
        self.visits[visit_idx].arrival_time = Some(prev_time + travel);
    }

    /// Post-update: compute vehicle cached aggregates.
    fn compute_vehicle_caches(&mut self, vehicle_idx: usize) {
        let v = &self.vehicles[vehicle_idx];
        let mut demand = 0i32;
        let mut driving = 0i64;
        let mut late = 0i64;
        let mut prev_loc = v.home_location.index;

        for &visit_idx in &v.visits {
            let visit = &self.visits[visit_idx];
            demand += visit.demand;
            driving += self.travel_time(prev_loc, visit.location.index);
            late += visit.late_minutes();
            prev_loc = visit.location.index;
        }
        driving += self.travel_time(prev_loc, self.vehicles[vehicle_idx].home_location.index);

        let v = &mut self.vehicles[vehicle_idx];
        v.cached_total_demand = demand;
        v.cached_driving_time = driving;
        v.cached_late_minutes = late;
    }
}
